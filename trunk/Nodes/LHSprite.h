//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.h
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __LHSPRITE_NODE__
#define __LHSPRITE_NODE__

#include "cocos2d.h"
#include "Box2d/Box2D.h"
#include "LHBezierNode.h"
#include "LHTouchMgr.h"
using namespace cocos2d;

class LevelHelperLoader;
class LHPathNode;
class LHAnimationNode;
class LHParallaxNode;
class LHJoint;

class LHSprite : public CCSprite, public CCStandardTouchDelegate
{
protected:
	b2Body* body; //week ptr
    std::string uniqueName;
    std::map<std::string, void*> customUserValues;
    
    int currentFrame;
    LHAnimationNode* animation;
    LHPathNode* pathNode;
    
    LHParallaxNode* parallaxNode;
    
    CCSize realScale; //used for the joints in case you create a level with SD graphics using ipad template
    
    LHParallaxNode* parallaxFollowingThisSprite;
    
    LevelHelperLoader* parentLoader;
    
    LHObserverPair touchBeginObserver;
    LHObserverPair touchMovedObserver;
    LHObserverPair touchEndedObserver;
    bool swallowTouches;
    LHObserverPair* tagTouchBeginObserver;
    LHObserverPair* tagTouchMovedObserver;
    LHObserverPair* tagTouchEndedObserver;

    
    friend class LHParallaxNode;
    friend class LevelHelperLoader;
    friend class LHAnimationNode;
    friend class LHPathNode;
public:

    CCSize getRealScale(){return realScale;}
    void setRealScale(CCSize scale){realScale = scale;}
    
    //INFO
    //--------------------------------------------------------------------------
    const std::string& getUniqueName(void);
    
    void setBody(b2Body* body);
    b2Body* getBody(void);
    bool removeBodyFromWorld(void); 
    
    //ANIMATION
    //--------------------------------------------------------------------------
    void startAnimationNamed(const std::string& animName,                         
                             int startFrame = 0,
                             CCObject* customAnimNotifierId = NULL,
                             SEL_CallFuncND customAnimNotifierSel = NULL,
                             bool observeLooping = false);

    //does not start the animation - just changed the texture. 
    //use this when you want to use nextFrame / prevFrame methods
    void prepareAnimationNamed(const std::string& animName);

    void stopAnimation(void);
    
    
    void setAnimation(LHAnimationNode* anim); //use wisely e.g. don't use it
    LHAnimationNode* getAnimation(void);
    std::string getAnimationName(void);
    
    int getNumberOfFrames(void);    
    void setFrame(int frmNo);
    int  getCurrentFrame(void);
    
    
    void nextFrame();
    void prevFrame();
    
    void nextFrameAndRepeat(); //will loop when it reaches end
    void prevFrameAndRepeat(); //will loop when it reaches start
    
    bool isAtLastFrame();
    
    //------------------------------------------------------------------------------
    
    
    //PATH METHODS
    //------------------------------------------------------------------------------
    void  moveOnPathWithUniqueName(const std::string& pathName,
                                   float movementTime,
                                   bool startAtEndPoint,
                                   bool isCyclic,
                                   bool restartOtherEnd,
                                   int axisOrientation,
                                   bool flipx,
                                   bool flipy,
                                   bool dMove,//describe path movement without setting the sprite position on the actual points on the path
                                   CCObject* obj = NULL,
                                   SEL_CallFuncN sel = NULL);

    
    LHPathNode* getPathNode(void);
    void cancelPathMovement(void);//will remove the path node if any - sprite will no longer move on a path
    void pausePathMovement(const bool& pauseStatus);
    
    void setPathSpeed(float value);
    float getPathSpeed(void);
    
    void registerNotifierOnPathEndPoints(CCObject* obj, 
                                         SEL_CallFuncN sel);

    //PARALLAX
    //--------------------------------------------------------------------------
    LHParallaxNode* getParallaxNode(void){return parallaxNode;}

    
    //USER INFO
    //--------------------------------------------------------------------------
    void setCustomValue(void* value, const char* key);
    void* getCustomValueWithKey(const char* key);
    
    //TRANSFORMATIONS
    //--------------------------------------------------------------------------
    //The following method will transform the physic body also - if any
    void transformPosition(CCPoint pos);    
    void transformRotation(float rot);
    
    //JOINTS LIST
    //--------------------------------------------------------------------------
    //returns the LHJoint* objects attached to the body of this sprite
    //from the LHJoint you can take back the box2d joint
    CCArray* jointList(void);//
    LHJoint* jointWithUniqueName(const std::string& name);
    
    //remove all joints attached to this sprite
    //methods may not remove the joints if body is in contact 
    //but rather is markes the joints for removal 
    //so make sure you call removeMarkedJoints from LevelHelperLoader.h in your tick method
    bool removeAllAttachedJoints(void);
    bool removeJoint(LHJoint* jt);

    
    //TOUCH METHODS
    //--------------------------------------------------------------------------
    //If NO_PHYSICS type - touch is detected inside the sprite quad, meaning touch can be
    //detected on the non visible part of the sprite also.
    
    //If sprite has physics - touch is detected on the body of the sprite, meaning touch will be detected
    //based on the shape of the body - useful when you dont want to detect touch on the non visible part
    //of the sprite
    bool isTouchedAtPoint(CCPoint point);
    
    //selector needs to have this signature void HelloWorldLayer::touchXXX:(LHTouchInfo*)info
    //in visual studio the method signature should be void HelloWorldLayer::touchXXX(CCObject* cinfo){LHTouchInfo* info = (LHTouchInfo*)info; ...} because compiler doesn't know how to cast
    //info will have all information regarding the touch (see API Documentation or top of this file)
    //for generic touch on sprites with tag use the observers from LevelHelperLoader
    void registerTouchBeginObserver(CCObject* observer, SEL_CallFuncO selector);
    void registerTouchMovedObserver(CCObject* observer, SEL_CallFuncO selector);
    void registerTouchEndedObserver(CCObject* observer, SEL_CallFuncO selector);

    virtual bool ccTouchBegan(CCTouch *pTouch, CCEvent *pEvent);
    virtual void ccTouchMoved(CCTouch *pTouch, CCEvent *pEvent);
	virtual void ccTouchEnded(CCTouch *pTouch, CCEvent *pEvent);
	virtual void ccTouchCancelled(CCTouch *pTouch, CCEvent *pEvent);
    //CLASS METHODS
    //------------------------------------------------------------------------------
    static std::string uniqueNameForBody(b2Body* body);
    static LHSprite* spriteForBody(b2Body* body);
    static int tagForBody(b2Body* body);
    static bool isLHSprite(CCNode* obj);

    
    virtual void touchDelegateRetain() {} //compatibility with old cocos2d-x version
    virtual void touchDelegateRelease() {}//compatibility with old cocos2d-x version
public:
    //CONSTRUCTORS
    virtual bool init(void);
    virtual ~LHSprite(void);
	LHSprite();    
    
    //static int numberOfSprites;
    
    static LHSprite* sprite(void);
    static LHSprite* spriteWithTexture(CCTexture2D *pTexture);
	static LHSprite* spriteWithTexture(CCTexture2D *pTexture, const CCRect& rect);
    static LHSprite* spriteWithTexture(CCTexture2D *pTexture, const CCRect& rect, const CCPoint& offset);
	static LHSprite* spriteWithSpriteFrame(CCSpriteFrame *pSpriteFrame);
	static LHSprite* spriteWithSpriteFrameName(const char *pszSpriteFrameName);
    static LHSprite* spriteWithFile(const char *pszFileName);
	static LHSprite* spriteWithFile(const char *pszFileName, const CCRect& rect);
    static LHSprite* spriteWithBatchNode(CCSpriteBatchNode *batchNode, const CCRect& rect);
    
    //overwrite this method in your custom sprite class if you want to do special
    //logic after the complete initialization - like working on the b2body
    virtual void postInit(void){}; 

    void setAnimationSequence(CCObject* seq); 
private:
    void setUniqueName(const char* name);
  
    void setPathNode(LHPathNode* node);
    void setParallaxNode(LHParallaxNode*node){parallaxNode = node;}
    
    void setTagTouchBeginObserver(LHObserverPair* pair);
    void setTagTouchMovedObserver(LHObserverPair* pair);
    void setTagTouchEndedObserver(LHObserverPair* pair);
};
////////////////////////////////////////////////////////////////////////////////

#endif
